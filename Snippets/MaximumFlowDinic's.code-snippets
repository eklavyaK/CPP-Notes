{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Print to console": {
		"scope": "cpp",
		"prefix": "gggg_gdinic_gmax_gflow",
		"body": [
			"ll dinic(vector<vector<pair<ll,ll>>> T, ll n, ll src, ll snk){",
				"\tif(src > n || snk > n || src <=0 || snk <= 0) return 0ll;",
				"\tvector<vector<bool>> I(n+5,vector<bool>(n+5));",
				"\tvector<vector<ll>> p(n+5,vector<ll>(n+5,-1));",
				"\tvector<vector<pair<ll,ll>>> G(n+5);",
				"\tvector<ll> L(n+5), id(n+5);",
				"\tfor(ll u=1;u<=n;u++){",
					"\t\tfor(ll j=0;j<(ll)T[u].size();j++){",
						"\t\t\tauto [v,cap] = T[u][j];",
						"\t\t\tif(p[u][v] == -1) p[u][v] = (ll) G[u].size(), p[v][u] = (ll) G[v].size(), G[u].push_back({v,0}), G[v].push_back({u,0});",
						"\t\t\tG[u][p[u][v]].second += cap, I[u][v] = G[u][p[u][v]].second > 0;",
					"\t\t}",
				"\t}",
				"\tauto bfs = [&](){",
					"\t\tL.assign(n+5,-1), L[src] = 0;",
					"\t\tqueue<ll> q; q.push(src);",
					"\t\twhile(!q.empty()){",
						"\t\t\tll u = q.front(); q.pop();",
						"\t\t\tfor(auto [v,c] : G[u]) if(c > 0 && L[v] == -1) L[v] = L[u] + 1, q.push(v);",
					"\t\t}",
					"\t\treturn L[snk] != -1;",
				"\t};",
				"\tfunction<ll(ll,ll)> dfs = [&](ll u, ll pushed){",
					"\t\tif(u == snk) return pushed;",
					"\t\tfor(;id[u] < (ll) G[u].size();id[u]++){",
						"\t\t\tauto [v, c] = G[u][id[u]];",
						"\t\t\tif(L[v] != L[u] + 1 || c <= 0) continue;",
						"\t\t\tif(ll flo = dfs(v, min(pushed, c))){",
							"\t\t\t\tG[u][id[u]].second -= flo, G[v][p[v][u]].second += flo;",
							"\t\t\t\treturn flo;",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn 0ll;",
				"\t};",
				"\tll maxflo = 0;",
				"\tif(snk == src) return -1ll;",
				"\twhile(bfs()) id.assign(n+5,0), maxflo += dfs(src,8e18);",
				"\t",
				"\t\"To find MIN CUT EDGES we vist all the nodes from the source such that these nodes are connected to source with a sequence of positive flow in RESIDUAL graph (obtained after the last bfs), visited and unvisited nodes will form two subgraphs, nodes connecting the subgraphs must be saturated, so their residual cap is 0, after this we just check if a edge connects a visited node and an unvisited node and it EXISTED in the initial graph with positive cap, then it will be a min cut edge\";",
				"\t// id.assign(n+5,0); vector<pair<int,int>> edges;",
				"\t// function<void(int)> add = [&](int u){",
				"\t//     id[u] = 1;",
				"\t//     for(auto [v,c] : G[u]) if(!id[v] && c>0) add(v);",
				"\t// };",
				"\t// add(src);",
				"\t// for(int u=1;u<=n;u++) if(id[u]) for(auto [v,c] : G[u]) if(!id[v] && I[u][v]) edges.push_back({u,v});",
				"\t",
				"\t\"To find maximum number of DISJOINT PATHS we just simply begin from source and go along the path which EXISTED in original graph with a positive cap and got vanished (cap is reduced to 0) after pushing the flow, we'are sure to find a distinct path (no edges are common) along it because if two paths have a common edge one of them shuouldn't exist\";",
				"\t// id.assign(n+5,0); vector<int> path;",
				"\t// function<void(int)> go = [&](int u){",
				"\t//     path.push_back(u);",
				"\t//     if(u == snk){",
				"\t//         cout<< endl << (int) path.size() << endl;",
				"\t//         for(auto i : path) cout<< i << \" \";",
				"\t//         return;",
				"\t//     }",
				"\t//     for(;id[u] < (int)G[u].size();id[u]++){",
				"\t//         auto [v,c] = G[u][id[u]];",
				"\t//         if(I[u][v] && c<=0){",
				"\t//             I[u][v] = 0, go(v);",
				"\t//             path.pop_back();",
				"\t//             if(u != src) return;",
				"\t//         }",
				"\t//     }",
				"\t// };",
				"\t// go(src);",
				"\t",
				"\treturn maxflo;",
			"}",
		],
		"description": "Log output to console"
	}
}