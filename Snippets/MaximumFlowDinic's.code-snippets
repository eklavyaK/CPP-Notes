{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Print to console": {
		"scope": "cpp",
		"prefix": "gggg_gdinic",
		"body": [
			"const int N = 505;  //max nodes",
			"unsigned int pos[N];",
			"int in[N][N],dis[N];",
			"map<int,map<int,int>> check;",
			"vector<pair<int,ll>> graph[N];",
			"int s,f,n,m;ll ans;  //n,m declared",
			"vector<vector<int>> disjpth;",
			"vector<int> track;",
			"int flow[N][N];",
			"bool bfs(){",
				"\tfill(dis,dis+n+1,N);",
				"\tbool done[n+1]{};",
				"\tqueue<int> Q; Q.push(s);",
				"\tdone[s] = 1; dis[s] = 0;",
				"\twhile(!Q.empty()){",
					"\t\tint node = Q.front(); Q.pop();",
					"\t\tfor(auto [to, cap] : graph[node]){",
						"\t\t\tif(!done[to] && cap>0){",
							"\t\t\t\tdis[to] = dis[node]+1;",
							"\t\t\t\tdone[to]=1;Q.push(to);",
						"\t\t\t}",
					"\t\t}",
					"\t\tif(dis[node]>dis[f])break;",
				"\t}",
				"\treturn done[f];",
			"}",
			"ll dfs(int node, ll flo){",
				"\tif(node==f)return flo;",
				"\tfor(;pos[node]<graph[node].size();pos[node]++){",
					"\t\tauto [u,cap] = graph[node][pos[node]];",
					"\t\tif(dis[u]==dis[node]+1 && cap>0){",
						"\t\t\tll c = dfs(u,min(flo,cap));",
						"\t\t\tif(!c) continue;",
						"\t\t\tgraph[u][in[u][node]].S+=c;",
						"\t\t\tgraph[node][pos[node]].S-=c;",
						"\t\t\treturn c;",
					"\t\t}",
				"\t}",
				"\treturn 0;",
			"}",
			"void Dinic(int start, int final){",
				"\tans = 0;check.clear();",
				"\ts = start; f = final;",
				"\tfor(int i=0;i<m;i++){",
					"\t\tint u, v; ll c; cin>>u>>v>>c;",
					"\t\tflow[u][v]=1;",
					"\t\tif(!check[u].count(v)){",
						"\t\t\tin[u][v]=graph[u].size();",
						"\t\t\tgraph[u].push_back({v,c});",
						"\t\t\tin[v][u]=graph[v].size();",
						"\t\t\tgraph[v].push_back({u,0});   //for undirected graph replace the 0 with c",
						"\t\t\tcheck[u][v]; check[v][u];",
					"\t\t}",
					"\t\telse{",
						"\t\t\tgraph[u][in[u][v]].S+=c;",
					"\t\t}",
				"\t}",
				"\twhile(bfs()){",
					"\t\tfill(pos,pos+n+1,0);",
					"\t\tfor(;pos[s]<graph[s].size();pos[s]++){",
						"\t\t\tauto [u,cap] = graph[s][pos[s]];",
						"\t\t\tif(dis[u]==dis[s]+1 && cap>0){;",
							"\t\t\t\tll c = dfs(u,cap);",
							"\t\t\t\tif(!c) continue;",
							"\t\t\t\tgraph[u][in[u][s]].S+=c;",
							"\t\t\t\tgraph[s][pos[s]].S-=c;",
							"\t\t\t\tans+=c;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tcout<<ans<<endl;           //maximum flow and minimum cut and maximum disjoint paths",
				"",
				"",
				"",
				"\t//bool vis[n+1]{};",
				"\t//function<void(int)> dfsmincut = [&](int node){",
				"\t//\tvis[node]=true;",
				"\t//\tfor(auto [u,cap] : graph[node]){",
				"\t//\t\tif(!vis[u] && cap>0)",
				"\t//\t\t\tdfsmincut(u);",
				"\t//\t}",
				"\t//};",
				"\t//dfsmincut(s);",
				"\t//set<pii> st;                //------------------> commented code for finding MINIMUM CUT EDGES",
				"\t//for(auto vec : graph){",
				"\t//\tfor(auto [node,cap] : vec){",
				"\t//\t\tif(vis[node]){",
				"\t//\t\t\tfor(auto [u,_] : graph[node]){",
				"\t//\t\t\t\tif(!vis[u]){",
				"\t//\t\t\t\t\tst.insert({node,u});",
				"\t//\t\t\t\t}",
				"\t//\t\t\t}",
				"\t//\t\t}",
				"\t//\t}",
				"\t//}",
				"\t//for(auto [a,b] : st)cout<<a<<' '<<b<<endl;  //edges to be removed",
				"",
				"",
				"",
				"\t//fill(pos,pos+n+1,0);",
				"\t//bool ok = false;",
				"\t//function<void(int)> findpath=[&](int node){",
					"\t//\ttrack.push_back(node);",
					"\t//\tif(node==f){",
						"\t//\t\tok = true;",
						"\t//\t\tdisjpth.push_back(track);",
						"\t//\t\ttrack.pop_back();",
						"\t//\t\treturn;",
					"\t//\t}                      //----------------------------> code to find MAXIMUM DISJOINT EDGES from s to f",
					"\t//\tfor(;pos[node]<graph[node].size();){",
						"\t//\t\tauto [u,cap]=graph[node][pos[node]];",
						"\t//\t\tif(cap<=0 && flow[node][u]){",
							"\t//\t\t\tpos[node]++;",
							"\t//\t\t\tfindpath(u);",
							"\t//\t\t\tif(ok){",
								"\t//\t\t\t\tif(node==s)ok=false;",
								"\t//\t\t\t\telse break;",
							"\t//\t\t\t}",
						"\t//\t\t}",
						"\t//\t\telse pos[node]++;",
					"\t//\t}",
					"\t//\ttrack.pop_back();",
				"\t//};",
				"\t//findpath(s);",
				"\t//for(auto vec : disjpth){",
					"\t//\tcout<<vec.size()<<endl;",
					"\t//\tfor(auto i : vec)",
					"\t//\tcout<<i<<' ';cout<<endl;",
				"\t//}",
			"}",
		],
		"description": "Log output to console"
	}
}